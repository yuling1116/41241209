# 41241209

作業二

Problem：Polynomial 多項式實作與運算

## 解題說明

本題要求實作一個 Polynomial 類別，表示一個由數個非零項所構成的一元多項式。
多項式建構與儲存（使用動態陣列）
多項式加法與乘法運算
評估 𝑝(𝑥)的值
多項式的輸入與輸出（使用 >>、<< 運算子重載）

### 解題策略
資料結構設計
1. Term 類別：用來表示每一項的係數與指數。
2. Polynomial 類別：
使用一個 Term 陣列記錄多項式所有非零項。
包含容量 capacity 與目前實際項數 terms。
當項數超過容量時自動擴充陣列。

運算實作策略
加法：從兩個已排序的多項式合併成新的多項式（類似 merge 過程）。
乘法：使用雙層迴圈將每一項相乘，再整理合併相同次方的項。
評估 Eval：使用 pow() 函數依據 𝑥 的值計算結果。

## 程式實作

以下為主要程式碼：

```cpp
class Polynomial {
private:
    Term* termArray;
    int capacity, terms;
    void resize();  // 自動擴充陣列容量

public:
    Polynomial();
    ~Polynomial();

    void newTerm(float coef, int exp);
    float Eval(float x);
    Polynomial Add(Polynomial b);
    Polynomial Mult(Polynomial b);

    friend istream& operator>>(istream& in, Polynomial& p);
    friend ostream& operator<<(ostream& out, const Polynomial& p);
};
```

## 效能分析

| 項目     | 時間複雜度          | 空間複雜度          | 說明          |
| ------ | -------------- | -------------- | ----------- |
| `Add`  | $O(m + n)$     | $O(m+n)$       | 合併兩個排序陣列    |
| `Mult` | $O(m \cdot n)$ | $O(m \cdot n)$ | 項項相乘並整理重複指數 |
| `Eval` | $O(n)$         | $O(1)$         | 每項評估一次即可    |

## 測試與驗證
| 測試案例 | 多項式 P(x)    | 多項式 Q(x)     | P+Q 結果      | P×Q 結果                       |
| ---- | ----------- | ------------ | ----------- | ---------------------------- |
| 測試一  | 2x^1 + 3x^0 | x^1 + 1      | 3x^1 + 4x^0 | 2x^2 + 5x^1 + 3x^0           |
| 測試二  | 5x^3 + 2x^1 | -5x^3 + 4x^0 | 2x^1 + 4x^0 | -25x^6 -10x^4 + 20x^3 + 8x^1 |
| 測試三  | 空多項式        | 任意多項式 Q(x)   | Q(x)        | 0                            |

| 多項式           | x=1 | x=2 | x=3 |
| ------------- | --- | --- | --- |
| 3x^2 + 2x + 1 | 6   | 17  | 34  |
| x^3 + 1       | 2   | 9   | 28  |

### 編譯與執行指令

```shell
g++ -std=c++17 main.cpp -o polynomial
./polynomial
```

### 結論

1. 本作業成功實作了多項式的加法、乘法與評估。
2. 使用物件導向與動態記憶體管理方式，讓程式具延展性。
3. 在輸出與輸入方面使用了 << 和 >> 運算子重載，符合 C++ 語法設計習慣。
4. 多項式乘法時間複雜度較高，若項數過多需考慮演算法優化。

## 申論及開發報告

### 選擇遞迴的原因

在本程式中，使用遞迴來計算連加總和的主要原因如下：

1. **資料結構選擇**
   本題核心在於如何表示一個多項式，使用結構 Term 搭配動態陣列是較為彈性且簡潔的方式。
   
２. **動態記憶體管理**  
　　透過 resize() 機制自動擴充容量，避免手動設定大小。

３. **錯誤與除錯**  
　　曾經因為陣列越界造成 segmentation fault，後來加上條件判斷與 resize() 修復。
    寫輸出運算子時忘記加空格導致格式錯誤，後來調整為清晰可讀的格式。

４. **程式風格與架構**  
　　使用模組化與類別成員封裝，使程式邏輯分層明確，容易維護。
