# 41241209

作業一

Problem 1：Ackermann 函數

## 解題說明

本題要求實作一個函式，計算 Ackermann 函數 $A(m, n)$ 的值。
Ackermann 函數是一個極快速增長的遞迴函數，是計算機科學中衡量遞迴與堆疊深度的經典範例之一。

### 解題策略

直接依照數學定義實作，程式邏輯與數學公式相對應：


## 程式實作

以下為主要程式碼：

```cpp
#include <iostream>
using namespace std;

int ackermann(int m, int n) {
    if (m < 0 || n < 0)
        throw "m or n < 0";
    else if (m == 0)
        return n + 1;
    else if (n == 0)
        return ackermann(m - 1, 1);
    return ackermann(m - 1, ackermann(m, n - 1));
}

int main() {
    int result = ackermann(2, 3);
    cout << result << '\n';
}
```

## 效能分析

1. 時間複雜度：超指數成長，理論上為 $O(A(m, n))$。
2. 空間複雜度：需佔用 $O(m+n)$ 的遞迴堆疊空間。

## 測試與驗證

### 測試案例
| 測試案例 | 輸入參數 \$(m, n)\$ | 預期輸出 | 遞迴輸出 | 一般輸出 |
| ---- | --------------- | ---- | ---- | ---- |
| 測試一  | \$(0, 0)\$      | 1    | 1    | 1    |
| 測試二  | \$(1, 2)\$      | 4    | 4    | 4    |
| 測試三  | \$(2, 2)\$      | 7    | 7    | 7    |
| 測試四  | \$(3, 3)\$      | 61   | 61   | 61   |
| 測試五  | \$(4, 1)\$      | 遞迴過深 | 無法計算 | 拋出異常 |


### 編譯與執行指令

```shell
$ g++ -std=c++17 -o ack ackermann.cpp
$ ./ack
```

### 結論

1. 當 $m \leq 3$ 時，使用公式推導方式可顯著提升效率。
2. 對於過大的 $m$，遞迴深度與計算量皆極大，應採用其他方法（如記憶化、動態規劃或限制範圍）

## 申論及開發報告

### 選擇遞迴的原因

在本程式中，使用遞迴來計算連加總和的主要原因如下：

1. **數學對應性高，邏輯清晰**
   使用遞迴是最直覺的方式，使用遞迴實作可以完全對應其數學邏輯，幫助我掌握「遞迴中再遞迴」的複雜嵌套結構。
   
２. **可觀察成長規律進行優化**  
　　對於 $m = 0 \sim 3$ 的範圍，Ackermann 函數的成長具規律性，適合轉換為封閉表達式或迴圈模擬，達到更好的效能與避免系統堆疊限制。

３. **開發過程中曾遇到無窮迴圈的錯誤**  
　　在撰寫非遞迴版本時，最初嘗試使用迴圈來模擬遞迴結構，但因為處理邏輯複雜，我曾錯誤地將 m 和 n 的變化順序寫反，或漏掉某些條件的終止判斷，導致程式進入無窮迴圈。
當時程式會卡死，CPU 使用率飆高，執行無法結束。我花了很多時間逐步印出變數狀態，例如印出每次迴圈中的 m、n 值，才發現部分情況下 m 並未遞減、n 一直卡在同一個值，導致條件永遠不成立。
這次經驗讓我深刻理解到：「即使不用遞迴，也要正確模擬遞迴結束條件」，不然會造成無限執行。透過這次錯誤，我學會了每一個邏輯分支都要有嚴謹的終止條件，不能有僥倖心理忽略某些情況。

４. **優化與學習成果**  
　　修正過程中，我改為對小範圍的 $m$ 進行逐一分析與列舉，設計出對應的封閉寫法與迴圈結構，程式不但穩定也能在常見輸入下快速執行。
  
作業一
Problem 2：Powerset 子集列舉

## 解題說明

本題要求使用遞迴方式實作 powerset（冪集合）生成演算法。Powerset 是一個集合的所有子集所構成的集合。

### 解題策略

1. 將問題拆解為：對於每個元素，我們有「取」或「不取」兩種選擇。

2. 使用遞迴函式 generatePowerset()：

   當走到底時（index == set.size()），把 current 子集合加入結果。

   否則：

   不選當前元素 → 遞迴

   選擇當前元素 → 加入 current，再遞迴

   回溯（pop 回前一步）

## 程式實作

以下為主要程式碼：

```cpp
#include <iostream>
#include "header.h"
using namespace std;

int main() {
    vector<char> set = {'a', 'b', 'c'};
    vector<char> current;
    vector<vector<char>> result;

    generatePowerset(set, 0, current, result);

    cout << "Powerset of { a, b, c }:\n";
    for (const auto& subset : result) {
        cout << "{ ";
        for (char ch : subset) cout << ch << " ";
        cout << "}\n";
    }

    return 0;
}
```

## 效能分析

1. 時間複雜度：每個元素有兩種選擇（取或不取），總共2n個子集合。
   時間複雜度為 O(2n)。

2. 空間複雜度：每層遞迴需要保存 current 狀態，最大為O(n)
   結果總共會存O(2n)組

## 測試與驗證

### 測試案例

| 測試案例 | 輸入集合    | 預期輸出子集數量 | 實際輸出子集數量 |
| ---- | ------- | -------- | -------- |
| 測試一  | {a}     | 2        | 2        |
| 測試二  | {a,b}   | 4        | 4        |
| 測試三  | {a,b,c} | 8        | 8        |
| 測試四  | 空集合 {}  | 1        | 1        |


### 編譯與執行指令

```shell
g++ -std=c++17 main.cpp -o powerset
./powerset
```

### 結論

1. 遞迴能成功列舉所有子集，並對每個元素進行「取/不取」兩分支遞迴。
2. 程式邏輯貼近組合數學的建構方式，適合學習遞迴與回溯。
3. 隨元素數量增長，powerset 的規模成指數成長，應避免處理太大集合。

## 申論及開發報告
在本題實作過程中，我學習到如何利用「回溯法」來產生所有可能的子集合（powerset）。這種方式對每個元素進行「選擇」與「不選擇」的遞迴拆解，讓我能清楚掌握 powerset 結構的產生邏輯。

實作上，我透過三個參數控制遞迴流程：目前的索引、目前子集合 current、整體結果集 result。當索引達到底時就代表走完一條分支，將當前子集加入結果中。這樣的邏輯對應到 powerset 的2n個組合，效果相當直觀。

在過程中我也曾遇到 bug，例如在回溯前忘了 pop_back()，導致子集合堆疊錯誤，或者是參數順序寫錯，造成遞迴邏輯混亂甚至 segmentation fault。這些經驗讓我深刻體會：即使是簡單的遞迴，也必須精準控制呼叫邏輯與狀態回復。

這題不但讓我練習了遞迴與回溯，也更熟悉如何在程式中維護多層次的遞迴狀態，並將結果有條理地儲存起來。
